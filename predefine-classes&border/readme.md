### 预定义类

正则表达式提供预定义类来匹配常见的字符类

| 字符 | 等价类          | 含义                             |
| ---- | --------------- | -------------------------------- |
| .    | [^\r\n]         | 除了回车符和换行符以外的所有字符 |
| \d   | [0-9]           | 数字字符                         |
| \D   | [^0-9]          | 非数字字符                       |
| \s   | [\t\n\x0B\f\r]  | 空白符                           |
| \S   | [^\t\n\x0B\f\r] | 非空白符                         |
| \w   | [a-zA-Z_0-9]    | 单词字符（字母、数字、下划线）   |
| \W   | [^a-zA-Z_0-9]   | 非单词字符                       |

使用预定义类可以快速匹配目标，如：匹配一个ab+数字+任意字符，使用字符类、范围类需要书写大量的代码，而使用预定义类只需要这样写：

```js
/ab\d/
```

### 边界

正则表达式还提供了几个常用的边界匹配字符

| 字符 | 含义       |
| ---- | ---------- |
| ^    | 以xxx开始  |
| $    | 以xxx结束  |
| \b   | 单词边界   |
| \B   | 非单词边界 |

当我们只想匹配一段话中中的部分单词而不是单词中的字母时，边界往往很有用

#### 单词边界与非单词边界

有时，我想匹配一句话中的is单词，而不想匹配在单词中的is字母，此时，使用单词边界可以轻松解决这个问题：

```js
let text = 'This is a boy'

let reg1 = /is/g

let reg2 = /\bis\b/g

text.replace(reg1, 'IS')	// 没有使用单词边界\b区分，结果为：ThIS IS a boy

text.replace(reg2, 'IS')	// 使用了单词边界进行区分，结果为：This IS a boy
```

而当我只想匹配作为单词结尾的is时，该怎么办？此时可以机智的混用单词边界与非单词边界：

```js
let text = 'This is a boy'

let reg3 = /\Bis\b/g

text.replace(reg3, 'IS')	// ThIS is a boy
```

#### ^ 和 $ —— 开始与结尾

很多使用，我们会想匹配开头或结尾的字符，使用`^` 和 `$`可以完美的解决这个问题：

```js
let text = '@123@abc@'

let reg1 = /@/g

text2.replace(reg1, 'Q')	// 没有使用^和$，匹配了所有的@，结果为：Q123QabcQ

let reg2 = /^@/g

text.replace(reg2, 'Q')		// 使用^匹配开头的@，结果为：Q123@abc@

let reg3 = /@$/g

text.replace(reg3, 'Q')		// 使用$匹配结尾的@，结果为：@123@abcQ
```

tips：实际使用中`^`需要写在匹配项的前方，而`$`需要卸载匹配项的后方

#### 在多行的情况下使用^和$

在多行的情况下，使用`m`进入多行模式才能匹配到每行的开头和结尾匹配字符：

```js
let text = '@123\n@456\n@789'

let reg1 = /^@\d/g

text.replace(reg1, 'Q')		 
/*
	由于换行实际上只是一个换行符字符，在正常模式下，依然看做一段字符
	结果为：
	Q23
	@456
	@789
*/

let reg2 = /^@\d/gm

text.replace(reg2, 'Q')
/*
	添加了m进入多行模式：
	结果为：
	Q23
	Q56
	Q89
*/
```

